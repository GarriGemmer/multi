#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os
import json
import logging
import asyncio
import random
import requests
from datetime import datetime
from dotenv import load_dotenv
from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup, InputFile
)
from telegram.ext import (
    ApplicationBuilder, CommandHandler, CallbackQueryHandler,
    ContextTypes, MessageHandler, filters
)

# --------------- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ----------------
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN", "7816419974:AAGDTqScu5OE2KvmGNPZA-BBYov0XnQCmgI")
ADMIN_ID = int(os.getenv("ADMIN_ID", "7167007722"))

POCKET_LINK = os.getenv("POCKET_LINK", "https://bit.ly/pocket-option-rus")
CHANNEL_LINK = os.getenv("CHANNEL_LINK", "https://t.me/your_channel")
SUPPORT_BOT = os.getenv("SUPPORT_BOT", "https://t.me/G0_PLUS_SUPPORTBOT")

# –ü—É—Ç–∏ –∫–∞—Ä—Ç–∏–Ω–æ–∫
PHOTOS = {
    "banner": "photo/banner.jpg",
    "register": "photo/banner.jpg",
    "limited": "photo/banner.jpg",
    "processing": "photo/banner.jpg",
    "final": "photo/banner.jpg",
}

ALLOWED_FILE = "allowed_users.json"

PAIRS = [
    "BTCUSDT", "ETHUSDT", "XRPUSDT", "LTCUSDT", "BNBUSDT",
    "SOLUSDT", "DOGEUSDT", "TRXUSDT", "ADAUSDT", "DOTUSDT",
    "EURUSD", "GBPUSD", "USDJPY", "AUDUSD", "USDCAD",
    "NZDUSD", "USDCHF", "EURGBP", "EURJPY", "GBPJPY",
]

TIMEFRAMES = [
    "1m", "5m", "15m", "30m", "1h", "2h", "4h", "6h", "8h", "12h",
    "1d", "3d", "1w", "1M", "1y"
]

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("goplus")

# -------- –ú—É–ª—å—Ç–∏—è–∑—ã—á–Ω—ã–µ —Ç–µ–∫—Å—Ç—ã -------------
TEXTS = {
    "ru": {
        "choose_lang": "–í—ã–±–µ—Ä–∏ —è–∑—ã–∫:",
        "active_caption": "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –ù–∞–∂–º–∏—Ç–µ ACTIVE —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å.",
        "welcome": "üëã –ü—Ä–∏–≤–µ—Ç! –Ø ‚Äî Go Plus, —Ç–≤–æ–π –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π —Ç–æ—Ä–≥–æ–≤—ã–π –±–æ—Ç.",
        "why": "‚ú® –ü–æ—á–µ–º—É –≤—ã–±–∏—Ä–∞—é—Ç Go Plus:\n‚Ä¢ –ë–æ–ª–µ–µ 100 –∞–∫—Ç–∏–≤–æ–≤\n‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∫–∞ OTC\n‚Ä¢ 2 —Ä–µ–∂–∏–º–∞ —Ç–æ—Ä–≥–æ–≤–ª–∏",
        "how": "ü§ñ –ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç:\n1) –í—ã–±–∏—Ä–∞–µ—à—å –∞–∫—Ç–∏–≤\n2) –£–∫–∞–∑—ã–≤–∞–µ—à—å –≤—Ä–µ–º—è\n3) –ü–æ–ª—É—á–∞–µ—à—å —Å–∏–≥–Ω–∞–ª\n4) –§–∏–∫—Å–∏—Ä—É–µ—à—å –ø—Ä–æ—Ñ–∏—Ç",
        "gpt": "ü§ñ –Ø –∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏–π –º–æ–¥—É–ª—å: –∞–Ω–∞–ª–∏–∑–∏—Ä—É—é –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ –∏ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤.",
        "register": f"‚ö° –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø, –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Å—è –ø–æ —Å—Å—ã–ª–∫–µ:\n{POCKET_LINK}\n\n–ò–ª–∏ –Ω–∞–∂–º–∏ –æ–¥–Ω—É –∏–∑ –∫–Ω–æ–ø–æ–∫ –Ω–∏–∂–µ.",
        "limited": "üîí –î–æ—Å—Ç—É–ø –æ–≥—Ä–∞–Ω–∏—á–µ–Ω. –û–∂–∏–¥–∞–π—Ç–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏.",
        "access_granted": "‚úÖ –î–æ—Å—Ç—É–ø –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω! –¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–æ—Ä–≥–æ–≤—É—é –ø–∞—Ä—É:",
        "choose_pair": "üìä –í—ã–±–µ—Ä–∏—Ç–µ —Ç–æ—Ä–≥–æ–≤—É—é –ø–∞—Ä—É:",
        "choose_tf": "‚è± –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∞–π–º—Ñ—Ä–µ–π–º:",
        "pair_chosen": "–ü–∞—Ä–∞: {pair}\n–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∞–π–º—Ñ—Ä–µ–π–º:",
        "time_chosen": "–¢–∞–π–º—Ñ—Ä–µ–π–º: {tf}\n\n–ù–∞—á–∏–Ω–∞—é –∞–Ω–∞–ª–∏–∑...",
        "anim_fetch": "üîÑ –ü–æ–ª—É—á–∞—é —Ä—ã–Ω–æ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ...",
        "anim_ind": "‚öôÔ∏è –í—ã—á–∏—Å–ª—è—é –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã...",
        "anim_check": "üîç –ü—Ä–æ–≤–µ—Ä—è—é —Å–∏–≥–Ω–∞–ª—ã...",
        "anim_done": "‚úÖ –ê–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à—ë–Ω!",
        "final": ("üìà –ü—Ä–æ–≥–Ω–æ–∑ ‚Äî {pair} / {tf}\n\n"
                  "üí∞ –¶–µ–Ω–∞ –ø–æ—Å–ª–µ–¥–Ω—è—è: {price}\n"
                  "üìä –ú–∏–Ω: {low}   –ú–∞–∫—Å: {high}\n"
                  "–°–∏–≥–Ω–∞–ª: {signal}\n"
                  "–î–æ–≤–µ—Ä–∏–µ: {conf}%\n\n–ü—Ä–∏—á–∏–Ω—ã:\n{reasons}"),
        "new_forecast": "–ù–æ–≤—ã–π –ø—Ä–æ–≥–Ω–æ–∑",
        "back_pairs": "‚¨ÖÔ∏è –ù–ê–ó–ê–î",
        "admin_notify": "–ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @{username} (ID: {uid}) –∑–∞–ø—Ä–æ—Å–∏–ª –¥–æ—Å—Ç—É–ø.",
        "only_admin": "‚ùå –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –º–æ–∂–µ—Ç –≤—ã–ø–æ–ª–Ω–∏—Ç—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É.",
        "allowed_ok": "‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {uid} —Ä–∞–∑—Ä–µ—à—ë–Ω.",
        "revoked_ok": "‚úÖ –î–æ—Å—Ç—É–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {uid} –æ—Ç–æ–∑–≤–∞–Ω.",
        "no_user": "‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {uid} –Ω–µ –Ω–∞–π–¥–µ–Ω.",
        "getid": "–í–∞—à Telegram ID: {uid}",
    },
    "en": {
        "choose_lang": "Choose your language:",
        "active_caption": "üëã Welcome! Press ACTIVE to begin.",
        "welcome": "üëã Hi, I'm Go Plus, your trading assistant bot.",
        "why": "‚ú® Why choose Go Plus:\n‚Ä¢ 100+ assets\n‚Ä¢ OTC support\n‚Ä¢ 2 modes\n‚Ä¢ instant analysis",
        "how": "ü§ñ How it works:\n1) Choose asset\n2) Choose timeframe\n3) Get a signal\n4) Take profit",
        "gpt": "ü§ñ I analyze many indicators and patterns for you.",
        "register": f"‚ö° To get access, register here:\n{POCKET_LINK}\n\nOr use one of the buttons below.",
        "limited": "üîí Access restricted. Please wait for activation.",
        "access_granted": "‚úÖ Access granted! Now choose a trading pair:",
        "choose_pair": "üìä Choose a trading pair:",
        "choose_tf": "‚è± Choose a timeframe:",
        "pair_chosen": "Pair: {pair}\nChoose timeframe:",
        "time_chosen": "Timeframe: {tf}\n\nStarting analysis...",
        "anim_fetch": "üîÑ Fetching market data...",
        "anim_ind": "‚öôÔ∏è Calculating indicators...",
        "anim_check": "üîç Checking signals...",
        "anim_done": "‚úÖ Analysis done!",
        "final": ("üìà Forecast ‚Äî {pair} / {tf}\n\n"
                  "üí∞ Last price: {price}\n"
                  "üìä Low: {low}   High: {high}\n"
                  "Signal: {signal}\n"
                  "Confidence: {conf}%\n\nReasons:\n{reasons}"),
        "new_forecast": "New Forecast",
        "back_pairs": "‚¨ÖÔ∏è BACK",
        "admin_notify": "New user @{username} (ID: {uid}) requested access.",
        "only_admin": "‚ùå Command available to admin only.",
        "allowed_ok": "‚úÖ User {uid} allowed.",
        "revoked_ok": "‚úÖ Access revoked for {uid}.",
        "no_user": "‚ùå User {uid} not found.",
        "getid": "Your Telegram ID: {uid}",
    },
    "hi": {
        "choose_lang": "‡§≠‡§æ‡§∑‡§æ ‡§ö‡•Å‡§®‡•á‡§Ç:",
        "active_caption": "üëã ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à! ACTIVE ‡§¶‡§¨‡§æ‡§è‡§Å‡•§",
        "welcome": "üëã ‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Æ‡•à‡§Ç Go Plus, ‡§Ü‡§™‡§ï‡§æ ‡§ü‡•ç‡§∞‡•á‡§°‡§ø‡§Ç‡§ó ‡§∏‡§π‡§æ‡§Ø‡§ï‡•§",
        "why": "‚ú® ‡§ï‡•ç‡§Ø‡•ã‡§Ç Go Plus:\n‚Ä¢ 100+ ‡§è‡§∏‡•á‡§ü‡•ç‡§∏\n‚Ä¢ OTC ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü\n‚Ä¢ 2 ‡§Æ‡•ã‡§°\n‚Ä¢ ‡§§‡•Å‡§∞‡§Ç‡§§ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£",
        "how": "ü§ñ ‡§Ø‡§π ‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à:\n1) ‡§è‡§∏‡•á‡§ü ‡§ö‡•Å‡§®‡•á‡§Ç\n2) ‡§ü‡§æ‡§á‡§Æ‡§´‡•ç‡§∞‡•á‡§Æ ‡§ö‡•Å‡§®‡•á‡§Ç\n3) ‡§∏‡§ø‡§ó‡•ç‡§®‡§≤ ‡§™‡§æ‡§è‡§Ç\n4) ‡§™‡•ç‡§∞‡•â‡§´‡§ø‡§ü ‡§≤‡•á‡§Ç",
        "gpt": "ü§ñ ‡§Æ‡•à‡§Ç ‡§ï‡§à ‡§∏‡§Ç‡§ï‡•á‡§§‡§ï‡•ã‡§Ç ‡§î‡§∞ ‡§™‡•à‡§ü‡§∞‡•ç‡§® ‡§ï‡•ã ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§ø‡§§ ‡§ï‡§∞‡§§‡§æ ‡§π‡•Ç‡§Å‡•§",
        "register": f"‚ö° ‡§è‡§ï‡•ç‡§∏‡•á‡§∏ ‡§™‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ø‡§π‡§æ‡§Å ‡§∞‡§ú‡§ø‡§∏‡•ç‡§ü‡§∞ ‡§ï‡§∞‡•á‡§Ç:\n{POCKET_LINK}\n\n‡§Ø‡§æ ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§¨‡§ü‡§® ‡§¶‡§¨‡§æ‡§è‡§Å‡•§",
        "limited": "üîí ‡§è‡§ï‡•ç‡§∏‡•á‡§∏ ‡§∏‡•Ä‡§Æ‡§ø‡§§ ‡§π‡•à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•ç‡§∞‡§§‡•Ä‡§ï‡•ç‡§∑‡§æ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "access_granted": "‚úÖ ‡§è‡§ï‡•ç‡§∏‡•á‡§∏ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ! ‡§Ö‡§¨ ‡§ú‡•ã‡§°‡§º‡•Ä ‡§ö‡•Å‡§®‡•á‡§Ç:",
        "choose_pair": "üìä ‡§è‡§ï ‡§ú‡•ã‡§°‡§º‡•Ä ‡§ö‡•Å‡§®‡•á‡§Ç:",
        "choose_tf": "‚è± ‡§è‡§ï ‡§ü‡§æ‡§á‡§Æ‡§´‡•ç‡§∞‡•á‡§Æ ‡§ö‡•Å‡§®‡•á‡§Ç:",
        "pair_chosen": "‡§ú‡•ã‡§°‡§º‡•Ä: {pair}\n‡§ü‡§æ‡§á‡§Æ‡§´‡•ç‡§∞‡•á‡§Æ ‡§ö‡•Å‡§®‡•á‡§Ç:",
        "time_chosen": "‡§ü‡§æ‡§á‡§Æ‡§´‡•ç‡§∞‡•á‡§Æ: {tf}\n\n‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§∂‡•Å‡§∞‡•Ç ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...",
        "anim_fetch": "üîÑ ‡§Æ‡§æ‡§∞‡•ç‡§ï‡•á‡§ü ‡§°‡•á‡§ü‡§æ ‡§≤‡§æ‡§Ø‡§æ ‡§ú‡§æ ‡§∞‡§π‡§æ ‡§π‡•à...",
        "anim_ind": "‚öôÔ∏è ‡§∏‡§Ç‡§ï‡•á‡§§‡§ï‡•ã‡§Ç ‡§ï‡•Ä ‡§ó‡§£‡§®‡§æ ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à...",
        "anim_check": "üîç ‡§∏‡§ø‡§ó‡•ç‡§®‡§≤ ‡§î‡§∞ ‡§µ‡•â‡§≤‡•ç‡§Ø‡•Ç‡§Æ ‡§ö‡•á‡§ï ‡§π‡•ã ‡§∞‡§π‡•á ‡§π‡•à‡§Ç...",
        "anim_done": "‚úÖ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§™‡•Ç‡§∞‡•ç‡§£!",
        "final": ("üìà ‡§™‡•Ç‡§∞‡•ç‡§µ‡§æ‡§®‡•Å‡§Æ‡§æ‡§® ‚Äî {pair} / {tf}\n\n"
                  "üí∞ ‡§Ö‡§Ç‡§§‡§ø‡§Æ ‡§Æ‡•Ç‡§≤‡•ç‡§Ø: {price}\n"
                  "üìä ‡§®‡•ç‡§Ø‡•Ç‡§®‡§§‡§Æ: {low}   ‡§Ö‡§ß‡§ø‡§ï‡§§‡§Æ: {high}\n"
                  "‡§∏‡§ø‡§ó‡•ç‡§®‡§≤: {signal}\n"
                  "‡§µ‡§ø‡§∂‡•ç‡§µ‡§æ‡§∏: {conf}%\n\n‡§ï‡§æ‡§∞‡§£:\n{reasons}"),
        "new_forecast": "‡§®‡§Ø‡§æ ‡§™‡•Ç‡§∞‡•ç‡§µ‡§æ‡§®‡•Å‡§Æ‡§æ‡§®",
        "back_pairs": "‚¨ÖÔ∏è ‡§µ‡§æ‡§™‡§∏",
        "admin_notify": "‡§®‡§è ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ @{username} (ID: {uid}) ‡§®‡•á ‡§è‡§ï‡•ç‡§∏‡•á‡§∏ ‡§Æ‡§æ‡§Ç‡§ó‡§æ‡•§",
        "only_admin": "‚ùå ‡§ï‡•á‡§µ‡§≤ ‡§è‡§°‡§Æ‡§ø‡§® ‡§π‡•Ä ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§ö‡§≤‡§æ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à‡•§",
        "allowed_ok": "‚úÖ ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ {uid} ‡§ï‡•ã ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§¶‡•Ä ‡§ó‡§à‡•§",
        "revoked_ok": "‚úÖ ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ {uid} ‡§ï‡§æ ‡§è‡§ï‡•ç‡§∏‡•á‡§∏ ‡§µ‡§æ‡§™‡§∏ ‡§≤‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ‡•§",
        "no_user": "‚ùå ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ {uid} ‡§∏‡•Ç‡§ö‡•Ä ‡§Æ‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§",
        "getid": "‡§Ü‡§™‡§ï‡§æ Telegram ID: {uid}",
    }
}

# -------- –§—É–Ω–∫—Ü–∏–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–∞–∑—Ä–µ—à—ë–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π ------------
def load_allowed():
    if os.path.exists(ALLOWED_FILE):
        try:
            with open(ALLOWED_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
            return set(data.get("allowed", []))
        except Exception as e:
            logger.warning("Load allowed error: %s", e)
    return set()

def save_allowed(s: set):
    try:
        with open(ALLOWED_FILE, "w", encoding="utf-8") as f:
            json.dump({"allowed": list(s)}, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logger.warning("Save allowed error: %s", e)

ALLOWED = load_allowed()

# ---------------- Keyboards ----------------
def kb_active():
    return InlineKeyboardMarkup([[InlineKeyboardButton("üîµ ACTIVE", callback_data="activate")]])

def kb_language():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data="lang_ru"),
         InlineKeyboardButton("üá¨üáß English", callback_data="lang_en"),
         InlineKeyboardButton("üáÆüá≥ ‡§π‡§ø‡§®‡•ç‡§¶‡•Ä", callback_data="lang_hi")]
    ])

def kb_register_stage(lang):
    t = TEXTS[lang]
    # Buttons: Register, Request Access, Write me ID, Our Channel
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("Register", url=POCKET_LINK)],
        [InlineKeyboardButton("Request Access", callback_data="request_access")],
        [InlineKeyboardButton("–ù–∞–ø–∏—à–∏ –º–Ω–µ ID", url="https://t.me/VikramBiz")],
        [InlineKeyboardButton("–ù–∞—à –∫–∞–Ω–∞–ª", url=CHANNEL_LINK)]
    ])

def kb_pairs(lang="ru"):
    kb = []
    for i in range(0, len(PAIRS), 4):
        row = [InlineKeyboardButton(p, callback_data=f"pair|{p}") for p in PAIRS[i:i+4]]
        kb.append(row)
    kb.append([InlineKeyboardButton(TEXTS[lang]["back_pairs"], callback_data="back_to_intro")])
    return InlineKeyboardMarkup(kb)

def kb_timeframes(lang="ru"):
    kb = []
    for i in range(0, len(TIMEFRAMES), 5):
        row = [InlineKeyboardButton(tf, callback_data=f"tf|{tf}") for tf in TIMEFRAMES[i:i+5]]
        kb.append(row)
    kb.append([InlineKeyboardButton(TEXTS[lang]["back_pairs"], callback_data="back_to_pairs")])
    return InlineKeyboardMarkup(kb)

# ---------------- Send photo helper ----------------
async def send_photo_or_text(context: ContextTypes.DEFAULT_TYPE, chat_id: int, photo_key: str, caption: str, reply_markup=None):
    path = PHOTOS.get(photo_key, PHOTOS["banner"])
    try:
        if os.path.exists(path):
            with open(path, "rb") as f:
                await context.bot.send_photo(chat_id=chat_id, photo=InputFile(f), caption=caption, reply_markup=reply_markup)
            return
    except Exception as e:
        logger.warning("Photo send fail: %s", e)
    await context.bot.send_message(chat_id=chat_id, text=caption, reply_markup=reply_markup)

# ---------------- Handlers ----------------
async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # initial
    context.user_data["lang"] = "ru"
    await send_photo_or_text(context, update.effective_chat.id, "banner", TEXTS["ru"]["active_caption"], reply_markup=kb_active())

async def activate_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    try:
        await q.message.delete()
    except Exception:
        pass
    await send_photo_or_text(context, q.message.chat.id, "banner", TEXTS["ru"]["choose_lang"], reply_markup=kb_language())

async def choose_lang(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    lang = q.data.split("_", 1)[1]
    context.user_data["lang"] = lang
    try:
        await q.message.delete()
    except Exception:
        pass

    # sequence: welcome -> why -> how -> gpt -> register
    await send_photo_or_text(context, q.message.chat.id, "banner", TEXTS[lang]["welcome"], reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚Üí", callback_data="step_why")]]))

async def step_why(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    lang = context.user_data.get("lang", "ru")
    try:
        await q.message.delete()
    except Exception:
        pass
    await send_photo_or_text(context, q.message.chat.id, "banner", TEXTS[lang]["why"], reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚Üí", callback_data="step_how")]]))

async def step_how(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    lang = context.user_data.get("lang", "ru")
    try:
        await q.message.delete()
    except Exception:
        pass
    await send_photo_or_text(context, q.message.chat.id, "banner", TEXTS[lang]["how"], reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚Üí", callback_data="step_gpt")]]))

async def step_gpt(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    lang = context.user_data.get("lang", "ru")
    try:
        await q.message.delete()
    except Exception:
        pass
    await send_photo_or_text(context, q.message.chat.id, "banner", TEXTS[lang]["gpt"], reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚Üí", callback_data="step_register")]]))

async def step_register(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    lang = context.user_data.get("lang", "ru")
    try:
        await q.message.delete()
    except Exception:
        pass
    await send_photo_or_text(context, q.message.chat.id, "register", TEXTS[lang]["register"], reply_markup=kb_register_stage(lang))
    # notify admin
    try:
        await context.bot.send_message(
            ADMIN_ID,
            TEXTS[lang]["admin_notify"].format(username=q.from_user.username or "‚Äî", uid=q.from_user.id)
        )
    except Exception as e:
        logger.warning("Admin notify failed: %s", e)

async def request_access_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    lang = context.user_data.get("lang", "ru")
    try:
        await q.message.delete()
    except Exception:
        pass
    await send_photo_or_text(context, q.message.chat.id, "limited", TEXTS[lang]["limited"])

async def cmd_allow(update: Update, context: ContextTypes.DEFAULT_TYPE):
    caller = update.effective_user.id
    if caller != ADMIN_ID:
        await update.message.reply_text(TEXTS["en"]["only_admin"])
        return
    if not context.args or not context.args[0].isdigit():
        await update.message.reply_text("Usage: /allow <user_id>")
        return
    uid = int(context.args[0])
    ALLOWED.add(uid)
    save_allowed(ALLOWED)
    await update.message.reply_text(TEXTS["en"]["allowed_ok"].format(uid=uid))
    # notify user
    lang = context.user_data.get("lang", "ru")
    try:
        await context.bot.send_message(uid, TEXTS[lang]["access_granted"], reply_markup=kb_pairs(lang))
    except Exception:
        pass

async def cmd_revoke(update: Update, context: ContextTypes.DEFAULT_TYPE):
    caller = update.effective_user.id
    if caller != ADMIN_ID:
        await update.message.reply_text(TEXTS["en"]["only_admin"])
        return
    if not context.args or not context.args[0].isdigit():
        await update.message.reply_text("Usage: /revoke <user_id>")
        return
    uid = int(context.args[0])
    if uid in ALLOWED:
        ALLOWED.remove(uid)
        save_allowed(ALLOWED)
        await update.message.reply_text(TEXTS["en"]["revoked_ok"].format(uid=uid))
        try:
            await context.bot.send_message(uid, TEXTS["ru"]["limited"])
        except Exception:
            pass
    else:
        await update.message.reply_text(TEXTS["en"]["no_user"].format(uid=uid))

async def cmd_signals(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lang = context.user_data.get("lang", "ru")
    if uid not in ALLOWED:
        await send_photo_or_text(context, update.effective_chat.id, "limited", TEXTS[lang]["limited"])
        return
    await send_photo_or_text(context, update.effective_chat.id, "banner", TEXTS[lang]["choose_pair"], reply_markup=kb_pairs(lang))

async def pair_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    uid = q.from_user.id
    lang = context.user_data.get("lang", "ru")
    if uid not in ALLOWED:
        await send_photo_or_text(context, q.message.chat.id, "limited", TEXTS[lang]["limited"])
        return
    _, pair = q.data.split("|", 1)
    context.user_data["pair"] = pair
    try:
        await q.message.delete()
    except Exception:
        pass
    await send_photo_or_text(context, q.message.chat.id, "banner", TEXTS[lang]["pair_chosen"].format(pair=pair), reply_markup=kb_timeframes(lang))

async def tf_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    uid = q.from_user.id
    lang = context.user_data.get("lang", "ru")
    if uid not in ALLOWED:
        await send_photo_or_text(context, q.message.chat.id, "limited", TEXTS[lang]["limited"])
        return
    _, tf = q.data.split("|", 1)
    pair = context.user_data.get("pair", "UNKNOWN")
    try:
        await q.message.delete()
    except Exception:
        pass

    # fetch real data for selected pair (if crypto)
    price = None
    low = None
    high = None
    try:
        # if pair ends with USDT => use Binance
        if pair.upper().endswith("USDT"):
            sym = pair.upper()
            resp = requests.get(f"https://api.binance.com/api/v3/ticker/24hr?symbol={sym}", timeout=5)
            data = resp.json()
            price = float(data.get("lastPrice", 0))
            low = float(data.get("lowPrice", 0))
            high = float(data.get("highPrice", 0))
        else:
            # fallback: random
            price = round(random.uniform(1.0, 2.0), 6)
            low = price * 0.99
            high = price * 1.01
    except Exception as e:
        logger.warning("Error fetching real data: %s", e)
        price = round(random.uniform(1.0, 2.0), 6)
        low = price * 0.99
        high = price * 1.01

    # animated steps (without graph)
    for step in (TEXTS[lang]["anim_fetch"], TEXTS[lang]["anim_ind"], TEXTS[lang]["anim_check"]):
        await send_photo_or_text(context, uid, "processing", step)
        await asyncio.sleep(1.0 + random.random() * 0.8)

    await send_photo_or_text(context, uid, "banner", TEXTS[lang]["anim_done"])
    await asyncio.sleep(0.8)

    # compute fake indicators
    sma_s = round(random.uniform(0.5, 1.5), 4)
    sma_l = round(sma_s + random.uniform(-0.02, 0.02), 4)
    rsi = round(random.uniform(20, 80), 1)
    macd = round(random.uniform(-0.5, 0.5), 3)
    vol_trend = random.choice(["increasing", "decreasing", "stable"])

    score = 0.0
    if sma_s > sma_l:
        score += 1.2
    else:
        score -= 1.2
    if rsi < 35:
        score += 1.0
    elif rsi > 65:
        score -= 1.0
    if macd > 0.02:
        score += 0.5
    elif macd < -0.02:
        score -= 0.5
    if vol_trend == "increasing":
        score += 0.3
    elif vol_trend == "decreasing":
        score -= 0.3

    if score >= 1.0:
        signal = "üìà BUY"
    elif score <= -1.0:
        signal = "üìâ SELL"
    else:
        signal = "‚ÜîÔ∏è NEUTRAL"

    conf = min(95, max(55, int(50 + abs(score)*20 + random.randint(-5, 5))))

    reasons = []
    reasons.append(f"SMA short ({sma_s}) {'>' if sma_s > sma_l else '<'} SMA long ({sma_l})")
    if rsi < 35:
        reasons.append(f"RSI {rsi}: oversold, possible bounce")
    elif rsi > 65:
        reasons.append(f"RSI {rsi}: overbought, possible correction")
    else:
        reasons.append(f"RSI {rsi}: neutral momentum")
    if macd > 0.02:
        reasons.append(f"MACD {macd}: positive momentum")
    elif macd < -0.02:
        reasons.append(f"MACD {macd}: negative momentum")
    else:
        reasons.append(f"MACD {macd}: flat")
    reasons.append(f"Volume trend: {vol_trend}")

    reasons_text = "\n".join("‚Ä¢ " + r for r in reasons)

    final = TEXTS[lang]["final"].format(
        pair=pair, tf=tf,
        price=price, low=low, high=high,
        signal=signal, conf=conf, reasons=reasons_text
    )

    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton(TEXTS[lang]["back_pairs"], callback_data="back_to_pairs")],
        [InlineKeyboardButton(TEXTS[lang]["new_forecast"], callback_data="pair|"+pair)]
    ])
    await send_photo_or_text(context, uid, "final", final, reply_markup=kb)

# handlers for back / new_forecast
async def back_to_pairs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    uid = q.from_user.id
    lang = context.user_data.get("lang", "ru")
    try:
        await q.message.delete()
    
